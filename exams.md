## Общие требования

- покрыть тестами, аннотировать, документировать
- одним файлом

## Fibonacci 

- написать функцию `fibonacci_iter()` возвращающую последовательность Фибоначчи
- написать функцию `fibonacci(n: int)` возвращающую число по индексу из последовательности
- использовать кеш для ответа `fibonacci_iter()` по ключу индекса
- например: `fibonacci(6) == 8`

## Classes

- описать классами рецепты 3-х пицц
- общие ингредиенты: тесто, томатная паста
- метод `dict(self)` возвращает словарь рецепта, 
  например: `Foo.dict() == {'dough': 100, 'tomato paste': 50, ...}`
- вызов `str(Foo())` возвращает рецепт строкой, 
  например: `str(Foo()) == 'Пеперони: dough 100, tomato paste 50, ...'`

## Logger

- написать параметрический декоратор, который логирует выполнение функции:
```
@timeit('prefix')
def incr(value):
    return value + 1

incr()
'prefix started'
'prefix finished'
```
- принимает необязательный аргумент префикса, иначе использует название функции
- для логирования использовать `debug()` из модуля `logging`
- в тестах проверить аргументы вызова `debug()` (замокать)

## Купи слона

- написать функцию `elephant()`, которая будет в консоль выводить `Купи слона`
  пока не получит положительный ответ
- использовать счетчик циклов: 5 попыток
- доводы для покупок должны быть разными
